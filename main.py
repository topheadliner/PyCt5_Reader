from PyQt5 import QtWidgets, QtCore
from PyQt5.QtWidgets import QApplication, QMainWindow, QMenuBar, QMenu, QFileDialog

import sys

class Window(QMainWindow):      #создаем класс, он может называться как угодно, и все наследуем от класса QMainWindow
    def __init__(self):     #разрабатываем конструктор
        super(Window,self).__init__()      #в конструкторе передаем различные параметры в родительский конструктор, обращаясь к нему через --init--()

        self.setWindowTitle("Code editor")    #обращаясь к self.* - обращаемся к окну
        self.setGeometry(300,250,350,200)   #по иксу на 300 пикселей сдвинуто вправо, по y на 250 вниз, далее ширина и высота

        self.text_edit = QtWidgets.QTextEdit(self)   #создаем объект - текстовый редактор, обращаемся к классу QtWidgets, из него выбирая QTextEdit, и self.* чтобы создать внутри основного окна
        self.setCentralWidget(self.text_edit)   #указываем объект, который займет всю ширину и высоту окна

        self.createMenuBar()   #будем вызывать метод, которого еще не существует - создаем сами ниже, в данном классе

    def createMenuBar(self):    #внутри метода прописываем все настройки относительно создания самого меню, для чего вернемся в начало и импортируем QMenuBar и QMenu
        self.menuBar = QMenuBar(self)     #создали глобальный объект menuBar, основанный на классе QMenuBar, объект сам из себя представляет полноценной меню, и приконтачим его к окну через self
        self.setMenuBar(self.menuBar)   #чтобы у окна было меню, обратимся к методу setMenuBar, в качестве меню указали наш объект

        #теперь добавляем элементы самого меню - пока что оно пустое
        fileMenu = QMenu("&file", self)      #элементы уже создаем на основе этого класса QMenu
        self.menuBar.addMenu(fileMenu)    #обратимся к меню целиком, укажем что добавляем внутрь меню данный пункт fileMenu

        ##open_file = fileMenu.addMenu("&open")    #обращаемся к основному пункту, и в нем создаем подпункт
        ##save_file = fileMenu.addMenu("&save")   #аналогично, но так в обоих случаях появляются не подпункты, а подменю, так что стираем
        #другой формат создаст конкретные пункты:
        fileMenu.addAction("open", self.action_clicked)     #в качестве параметра передадим имя пункта и тот метод, который сработает при нажатии
        fileMenu.addAction("save", self.action_clicked)     #и метод action_clicked создаем сами

    #чтобы он работал, нужна аннотация, в которой обратимся к классу QtCore, импортировав его в начале, через него - к pyqtSlot
    @QtCore.pyqtSlot()      #данная аннотация будет обрабатывать нажатие различных пунктов меню
    def action_clicked(self):
        action = self.sender()   #создаем переменную action, через sender получаем всю информацию относительно объекта - пункта меню, на который нажали
        #print("Action " + action.text())    #через метод *.text преобразуем объект к текстовой надписи, иначе выдаст ошибку

        #когда нажали кнопку open, то открывается диалоговое окно через которое выбираем некий текстовый файл,
        #считываем его и всю инфу полностью помещаем внутрь нашей программки текстового редактора:
        if action.text() == "open":
            fname = QFileDialog.getOpenFileName(self)[0]    #создаем объект fname, обращаясь к классу, класс подключаем в начале, через класс обращаемся к методу,
            # укажем параметр self и индекс 0 чтобы обратиться к этому одному файлу первому из всей выборки

            try:
                f = open(fname, 'r')    #создаем объект для прочтения файла, используя встроенный метод open
                #первый параметр - сам файл, второй - режим чтения 'r' - считывание файла
                with f:     #при прочтении:
                    data = f.read()    #кждый раз каждую строку файла помещаем в переменную data
                    self.text_edit.setText(data)  #каждый раз каждую строку помещаем внутрь текстового поля
                f.close()
            except FileNotFoundError:   #если не сделать через try-except, то когда мы не выберем файл, система все равно попытается его открыть
                print("No such file")

        elif action.text() == "save":
            fname = QFileDialog.getSaveFileName(self)[0]    #появится окно-меню для сохранения
            try:
                f = open(fname, 'w')
                text = self.text_edit.toPlainText()     #получим весь текст из текстового поля
                f.write(text)     #обращаемся к открытому файлу, к методу write,
                #и укажем что запишем внутрь файла тот текст, который получили из текстового редактора
                f.close()
            except FileNotFoundError:
                print("No such file")

def application():    #создаем основной метод, который вызывается при запуске файла
    app = QApplication(sys.argv)    #создаем объект (например app) на основе класса QApplication, argv - настройки относительно самой системе, в которой запустится проект
    window = Window()   #создаем окно на основе нашего класса

    window.show()   #чтобы окно показывалось
    sys.exit(app.exec_())    #для корректного завершения объекта app!

if __name__ == "__main__":     #если это основной файл, в котором будем запускать, то сразу запустится application
    application()

